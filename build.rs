use std::{env, ffi::OsStr, fs, io::Write, path::PathBuf};

fn is_ident_char(b: u8) -> bool {
    matches!(b, b'a'..=b'z' | b'A'..=b'Z' | b'0'..=b'9' | b'_')
}

fn rust_ident_from_case_name(name: &str) -> String {
    let mut out = String::with_capacity(name.len() + 8);
    out.push_str("case_");
    let mut prev_was_underscore = false;
    for &b in name.as_bytes() {
        let b = match b {
            b'a'..=b'z' | b'0'..=b'9' => b,
            b'A'..=b'Z' => b + 32,
            _ => b'_',
        };
        if b == b'_' {
            if prev_was_underscore {
                continue;
            }
            prev_was_underscore = true;
            out.push('_');
            continue;
        }

        prev_was_underscore = false;
        out.push(b as char);
    }

    // Ensure identifier doesn't end with underscore.
    while out.ends_with('_') {
        out.pop();
    }

    // Ensure identifier is a valid Rust ident start.
    if out.len() < 5 {
        out.push_str("unnamed");
    }
    let first = out.as_bytes().get(0).copied().unwrap_or(b'_');
    if !matches!(first, b'a'..=b'z' | b'A'..=b'Z' | b'_') {
        out.insert(0, '_');
    }

    // Defensive: strip any remaining invalid chars.
    if !out.as_bytes().iter().all(|&b| is_ident_char(b)) {
        out = out
            .bytes()
            .map(|b| if is_ident_char(b) { b as char } else { '_' })
            .collect();
    }
    out
}

fn main() {
    println!("cargo:rerun-if-env-changed=UPDATE_GOLDENS");

    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR"));
    // User-generated render cases live here.
    // (Project-owned fixtures should not go here; they belong under tests/fixtures/render_cases/.)
    let cases_root = manifest_dir.join("tests").join("cases");

    // Re-run build script if the cases root changes, and also on per-case files.
    // Note: directory watches can be flaky for add/remove on some setups, so we also
    // register concrete file paths for the discovered cases.
    println!("cargo:rerun-if-changed={}", cases_root.display());

    let mut case_dirs: Vec<(String, String)> = Vec::new(); // (case_name, scene_source_relative)
    if let Ok(entries) = fs::read_dir(&cases_root) {
        for entry in entries.flatten() {
            let path = entry.path();
            if !path.is_dir() {
                continue;
            }
            if path.file_name() == Some(OsStr::new("wgsl_generation")) {
                continue;
            }

            // Discover scene source: prefer .nforge, fall back to scene.json.
            let nforge = path.join("scene.nforge");
            let scene_json = path.join("scene.json");
            let scene_source = if nforge.exists() {
                nforge.clone()
            } else if scene_json.exists() {
                scene_json.clone()
            } else {
                continue;
            };

            // Always track these inputs for rebuild correctness.
            println!("cargo:rerun-if-changed={}", nforge.display());
            println!("cargo:rerun-if-changed={}", scene_json.display());
            let skip = path.join("SKIP_RENDER_CASE");
            println!("cargo:rerun-if-changed={}", skip.display());
            let baseline = path.join("baseline.png");
            println!("cargo:rerun-if-changed={}", baseline.display());

            if skip.exists() {
                continue;
            }
            if let Some(name) = path.file_name().and_then(|s| s.to_str()) {
                let relative = if scene_source == nforge {
                    format!("{}/scene.nforge", name)
                } else {
                    format!("{}/scene.json", name)
                };
                case_dirs.push((name.to_string(), relative));
            }
        }
    }
    case_dirs.sort();

    let out_dir = PathBuf::from(env::var("OUT_DIR").expect("OUT_DIR"));
    let dest_path = out_dir.join("generated_render_cases.rs");
    let mut f = fs::File::create(&dest_path).expect("create generated_render_cases.rs");

    writeln!(f, "// @generated by build.rs. Do not edit by hand.").unwrap();
    writeln!(
        f,
        "// Generated from tests/cases/* folders containing scene.nforge or scene.json."
    )
    .unwrap();
    writeln!(f).unwrap();

    for (case_name, scene_source) in &case_dirs {
        let ident = rust_ident_from_case_name(case_name);
        writeln!(f, "#[test]").unwrap();
        writeln!(f, "fn {ident}() {{").unwrap();
        writeln!(
            f,
            "    run_case(&Case {{ name: {case_name:?}, scene_source: {scene_source:?}, baseline_png: {baseline_png}, expected_image_texture: {expected_image_texture} }});",
             baseline_png = format!("default_baseline_png({:?})", case_name),
             expected_image_texture = format!("default_expected_image_texture({case_name:?})"),
         )
         .unwrap();
        writeln!(f, "}}").unwrap();
        writeln!(f).unwrap();
    }
}
