// Human-readable copy of the generated shader.
//
// Notes:
// - Intended for manual review only.
// - Keeps the same logic as `glass_pass.fragment.wgsl`, but with fewer autogenerated temps.

struct Params {
    target_size: vec2f,
    geo_size: vec2f,
    center: vec2f,
    time: f32,
    _pad0: f32,
    color: vec4f,
};

@group(0) @binding(0)
var<uniform> params: Params;

struct VSOut {
    @builtin(position) position: vec4f,
    @location(0) uv: vec2f,
    // GLSL-like gl_FragCoord.xy: bottom-left origin, pixel-centered.
    @location(1) frag_coord_gl: vec2f,
};

fn mc_math_centerPx(uGeoPxSize: vec2<f32>) -> vec2<f32> {
    var centerPx = uGeoPxSize.xy * 0.5;
    centerPx.y = uGeoPxSize.y - centerPx.y;
    return centerPx;
}

fn mc_math_calculateNormal(
    uvPx: vec2<f32>,
    centerPx: vec2<f32>,
    uGeoPxSize: vec2<f32>,
    r: f32,
) -> vec3<f32> {
    // Calculate 3D normal from SDF gradient (central differences)
    let p = uvPx - centerPx;
    let b = uGeoPxSize.xy * 0.5;

    let eps = 1.0;

    // Sample SDF at offset positions
    let dRight = abs(p + vec2<f32>(eps, 0.0)) - b + vec2<f32>(r);
    let dLeft  = abs(p - vec2<f32>(eps, 0.0)) - b + vec2<f32>(r);
    let dTop   = abs(p + vec2<f32>(0.0, eps)) - b + vec2<f32>(r);
    let dBottom= abs(p - vec2<f32>(0.0, eps)) - b + vec2<f32>(r);

    let sdfRight  = min(max(dRight.x,  dRight.y),  0.0) + length(max(dRight,  vec2(0.0))) - r;
    let sdfLeft   = min(max(dLeft.x,   dLeft.y),   0.0) + length(max(dLeft,   vec2(0.0))) - r;
    let sdfTop    = min(max(dTop.x,    dTop.y),    0.0) + length(max(dTop,    vec2(0.0))) - r;
    let sdfBottom = min(max(dBottom.x, dBottom.y), 0.0) + length(max(dBottom, vec2(0.0))) - r;

    let xyGradient = vec2<f32>(
        (sdfRight - sdfLeft) * 0.5,
        (sdfTop - sdfBottom) * 0.5,
    );

    return normalize(vec3<f32>(xyGradient, 1.0));
}

fn mc_math_calculateLighting(
    normal: vec3<f32>,
    uDirectionalLightDir: vec3<f32>,
    uDirectionalLightIntensity: f32,
) -> f32 {
    // Directional lighting calculation
    let normalizedLightDir = normalize(uDirectionalLightDir);
    let dotProduct = dot(normal, normalizedLightDir);

    // Reflection angle factor
    let reflectionAngle = acos(clamp(dotProduct, -1.0, 1.0));
    let angleFactor = 1.0 - (reflectionAngle / 1.570795); // (pi*0.5)

    var adjustedIntensity = uDirectionalLightIntensity * angleFactor;
    adjustedIntensity = max(adjustedIntensity, 0.0);

    return max(dotProduct, 0.0) * adjustedIntensity;
}

fn mc_math_shapeSdf(baseSdf: f32, uShapeEdgePx: f32, uShapeEdgePow: f32) -> f32 {
    // Apply edge curve to SDF
    var d = baseSdf;
    let edge = uShapeEdgePx;

    if (d < -edge) {
        d = -edge;
    } else if (d < 0.0) {
        let per = -d / edge;

        // smooth7_vertical approximation
        var t = pow(clamp(per, 0.0, 1.0), 0.5);
        t = mix(0.5, 1.0, t);
        t = clamp(t, 0.0, 1.0);

        let t2 = t * t;
        let t3 = t2 * t;
        let t4 = t3 * t;
        let t5 = t4 * t;
        let t6 = t5 * t;
        let t7 = t6 * t;

        t = -20.0 * t7 + 70.0 * t6 - 84.0 * t5 + 35.0 * t4;
        t = (t - 0.5) * 2.0;

        // Apply power curve
        let circlePow = 1.0 - pow(1.0 - t, uShapeEdgePow);
        d = -circlePow * edge;
    }

    return d;
}

fn mc_math_finalColor(
    uGlassColor: vec4<f32>,
    lighting: f32,
    luma: f32,
    shapeSdf: f32,
    uSaturation: f32,
    uBrightness: f32,
    uAlpha: f32,
    uStrength: f32,
) -> vec4<f32> {
    // Combine all glass effects into final color

    // RGB->HSV
    var hsv: vec3<f32>;
    {
        let K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);

        // This matches the generated shader exactly (it uses .zy / .yz swizzles).
        let p = mix(
            vec4(uGlassColor.zy, K.wz),
            vec4(uGlassColor.yz, K.xy),
            vec4(step(uGlassColor.z, uGlassColor.y)),
        );

        let q = mix(
            vec4(p.xyw, uGlassColor.x),
            vec4(uGlassColor.x, p.yzx),
            vec4(step(p.x, uGlassColor.x)),
        );

        let d = q.x - min(q.w, q.y);
        let e = 1e-10;

        hsv = vec3(
            abs(q.z + (q.w - q.y) / (6.0 * d + e)),
            d / (q.x + e),
            q.x,
        );
    }

    // Add lighting to value
    hsv.z = hsv.z + lighting * 1.2 * (1.0 - luma * 0.5);
    hsv.z = clamp(hsv.z, 0.0, 1.0);

    // HSV->RGB
    var rgb: vec3<f32>;
    {
        let K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
        let p = abs(fract(hsv.xxx + K.xyz) * 6.0 - K.www);
        rgb = hsv.z * mix(K.xxx, clamp(p - K.xxx, vec3(0.0), vec3(1.0)), vec3(hsv.y));
    }

    // Apply saturation and brightness adjustments
    let luminance = dot(rgb, vec3(0.2125, 0.7153, 0.0721));
    let adjustedSat = uSaturation * rgb + (1.0 - uSaturation) * vec3(luminance);
    let adjustedBright = adjustedSat + vec3(uBrightness);

    // Calculate final alpha
    var finalAlpha = smoothstep(0.0, 10.0, -shapeSdf);
    finalAlpha *= uAlpha * uStrength;

    var outColor = vec4(adjustedBright, finalAlpha);
    outColor.rgb *= outColor.a; // Premultiply alpha

    return outColor;
}

fn sdf2d_round_rect(p: vec2f, b: vec2f, rad4: vec4f) -> f32 {
    var r: f32 = rad4.x;
    if (p.x > 0.0 && p.y > 0.0) {
        r = rad4.y;
    } else if (p.x > 0.0 && p.y < 0.0) {
        r = rad4.z;
    } else if (p.x < 0.0 && p.y < 0.0) {
        r = rad4.w;
    }

    let q = abs(p) - b + vec2f(r, r);
    let outside = length(max(q, vec2f(0.0, 0.0)));
    let inside = min(max(q.x, q.y), 0.0);
    return outside + inside - r;
}

@fragment
fn fs_main(in: VSOut) -> @location(0) vec4f {
    let centerPx = mc_math_centerPx(params.geo_size);

    let uvPx = in.uv * params.geo_size;
    let normal = mc_math_calculateNormal(
        uvPx,
        centerPx,
        params.geo_size,
        20.0, // radius
    );

    let lighting = mc_math_calculateLighting(
        normal,
        vec3f(0.5, -0.7, 0.5),
        1.0,
    );

    let baseSdf = sdf2d_round_rect(
        (((in.uv - vec2f(0.5, 0.5)) * params.geo_size) - centerPx),
        params.geo_size * 0.5,
        vec4f(20.0),
    );

    let shapeSdf = mc_math_shapeSdf(
        baseSdf,
        30.0, // uShapeEdgePx
        2.0,  // uShapeEdgePow
    );

    // This is the constant value you see in the generated WGSL (premultiplied in finalColor).
    let uGlassColor = vec4f(0.6363, 0.67165, 0.707, 0.707);
    let luma = clamp(dot(uGlassColor.rgb, vec3f(0.2126, 0.7152, 0.0722)), 0.0, 1.0);

    return mc_math_finalColor(
        uGlassColor,
        lighting,
        luma,
        shapeSdf,
        1.0, // uSaturation
        0.0, // uBrightness
        1.0, // uAlpha
        1.0, // uStrength
    );
}
